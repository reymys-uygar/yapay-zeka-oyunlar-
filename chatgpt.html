<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Orbit Fracture</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: radial-gradient(circle at top, #1a2240, #05070f);
        overflow: hidden;
        font-family: "Segoe UI", system-ui, sans-serif;
        color: #e6ecff;
      }

      canvas {
        display: block;
      }

      #ui {
        position: absolute;
        top: 16px;
        left: 16px;
        background: rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(12px);
        border-radius: 14px;
        padding: 14px 18px;
        box-shadow: 0 0 40px rgba(120, 160, 255, 0.15);
      }

      #title {
        font-weight: 700;
        letter-spacing: 0.08em;
        font-size: 14px;
        opacity: 0.9;
      }

      #score {
        font-size: 26px;
        margin-top: 6px;
      }

      #hint {
        position: absolute;
        bottom: 18px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 13px;
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>

    <div id="ui">
      <div id="title">ORBIT FRACTURE</div>
      <div id="score">0</div>
    </div>

    <div id="hint">Drag wells • Scroll to change gravity • Space to pause</div>

    <script>
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      let W, H;
      function resize() {
        W = canvas.width = window.innerWidth;
        H = canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      let paused = false;
      document.addEventListener("keydown", (e) => {
        if (e.code === "Space") paused = !paused;
      });

      const wells = [
        {
          x: W / 2,
          y: H / 2,
          strength: 160,
        },
      ];

      let draggingWell = null;

      canvas.addEventListener("mousedown", (e) => {
        const r = canvas.getBoundingClientRect();
        const mx = e.clientX - r.left;
        const my = e.clientY - r.top;
        wells.forEach((w) => {
          if (Math.hypot(mx - w.x, my - w.y) < 28) draggingWell = w;
        });
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!draggingWell) return;
        const r = canvas.getBoundingClientRect();
        draggingWell.x = e.clientX - r.left;
        draggingWell.y = e.clientY - r.top;
      });

      canvas.addEventListener("mouseup", () => (draggingWell = null));

      canvas.addEventListener("wheel", (e) => {
        if (draggingWell) {
          draggingWell.strength = Math.max(
            60,
            Math.min(300, draggingWell.strength - e.deltaY * 0.3),
          );
        }
      });

      let shards = [];
      let cores = [];
      let score = 0;
      const scoreEl = document.getElementById("score");

      function spawnShard() {
        const edge = Math.floor(Math.random() * 4);
        let x, y, vx, vy;
        const speed = 1.4 + Math.random();
        if (edge === 0) {
          x = Math.random() * W;
          y = -20;
          vx = Math.random() - 0.5;
          vy = speed;
        }
        if (edge === 1) {
          x = W + 20;
          y = Math.random() * H;
          vx = -speed;
          vy = Math.random() - 0.5;
        }
        if (edge === 2) {
          x = Math.random() * W;
          y = H + 20;
          vx = Math.random() - 0.5;
          vy = -speed;
        }
        if (edge === 3) {
          x = -20;
          y = Math.random() * H;
          vx = speed;
          vy = Math.random() - 0.5;
        }

        shards.push({ x, y, vx, vy, life: 1 });
      }

      function spawnCore() {
        cores.push({
          x: Math.random() * (W * 0.6) + W * 0.2,
          y: Math.random() * (H * 0.6) + H * 0.2,
          pulse: 0,
        });
      }

      setInterval(spawnShard, 1100);
      setInterval(spawnCore, 6000);

      function update() {
        if (paused) return;

        shards.forEach((s) => {
          wells.forEach((w) => {
            const dx = w.x - s.x;
            const dy = w.y - s.y;
            const d = Math.hypot(dx, dy) + 0.1;
            const force = w.strength / (d * d);
            s.vx += (dx / d) * force * 0.02;
            s.vy += (dy / d) * force * 0.02;
          });
          s.x += s.vx;
          s.y += s.vy;
        });

        shards = shards.filter((s) => {
          for (let c of cores) {
            if (Math.hypot(s.x - c.x, s.y - c.y) < 20) {
              score++;
              scoreEl.textContent = score;
              return false;
            }
          }
          return s.x > -50 && s.x < W + 50 && s.y > -50 && s.y < H + 50;
        });

        cores.forEach((c) => (c.pulse += 0.04));
      }

      function draw() {
        ctx.clearRect(0, 0, W, H);

        // Stars
        for (let i = 0; i < 40; i++) {
          ctx.fillStyle = "rgba(255,255,255,0.03)";
          ctx.fillRect(Math.random() * W, Math.random() * H, 1, 1);
        }

        // Cores
        cores.forEach((c) => {
          const r = 14 + Math.sin(c.pulse) * 4;
          ctx.beginPath();
          ctx.arc(c.x, c.y, r, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(255,180,200,0.8)";
          ctx.shadowBlur = 20;
          ctx.shadowColor = "#ff9bbd";
          ctx.fill();
          ctx.shadowBlur = 0;
        });

        // Shards
        shards.forEach((s) => {
          ctx.beginPath();
          ctx.arc(s.x, s.y, 4, 0, Math.PI * 2);
          ctx.fillStyle = "#9fc6ff";
          ctx.fill();
        });

        // Wells
        wells.forEach((w) => {
          ctx.beginPath();
          ctx.arc(w.x, w.y, 24, 0, Math.PI * 2);
          ctx.strokeStyle = "rgba(160,200,255,0.8)";
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(w.x, w.y, w.strength * 0.15, 0, Math.PI * 2);
          ctx.strokeStyle = "rgba(120,160,255,0.1)";
          ctx.stroke();
        });
      }

      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }
      loop();
    </script>
  </body>
</html>
